原始数据：
PARTNO,P1,GP,H,JD,WD,TASK,PLANETYPE,DTRQ
20250611,251273059,251273059,0.0,0.0,0.0,942,大型机,11-JUN-25 03.00.00.000000 AM
20250611,251273059,251273059,0.0,0.0,0.0,942,大型机,11-JUN-25 03.00.30.000000 AM
20250611,251273059,251273059,0.0,0.0,0.0,942,大型机,11-JUN-25 03.01.00.000000 AM
20250611,251273059,251273059,0.0,0.0,0.0,942,大型机,11-JUN-25 03.01.30.000000 AM
20250611,251273059,251273059,0.0,0.0,0.0,942,大型机,11-JUN-25 03.02.00.000000 AM
20250611,251273059,251273059,2002.1761404374463,28.4619,41.1913,942,大型机,11-JUN-25 03.02.30.000000 AM
20250611,251273059,251273059,2026.3235967150129,28.4622,41.1915,942,大型机,11-JUN-25 03.03.00.000000 AM
20250611,251273059,251273059,2050.4490717760395,28.4624,41.1918,942,大型机,11-JUN-25 03.03.30.000000 AM
20250611,251273059,251273059,2074.5305844039867,28.4627,41.192,942,大型机,11-JUN-25 03.04.00.000000 AM
原始数据：
GBK编码
采样间隔不定
PARTNO：日期，只精确到日
P1：飞行id号码，随时间会出现复用。并不位唯一。 
GP：字符串显示
H：高度，float，度分秒格式 
JD：经度，float，度分秒格式 
WD：纬度，float，度分秒格式 
TASK：任务，字符串
PLANETYPE：机型，字符串，会包含中文
DTRQ：时间戳，11-JUN-25 03.00.00.000000 AM，日-月-年 小时.分钟.秒.微妙

经过我们的数据集清洗程序，得到清洗好的数据（这个清洗数据格式是可以修改的，为后面web可视化服务）。
这部分功能尚未实现（可以基于[text](run_flight_preprocess.sh) [text](flight_preprocess.py)基于这两个脚本实现代码。但是不要修改原来的代码，请创建新的代码文件）
清洗好的推理演示数据集据格式：
UTF-8编码
采样间隔1秒或者5秒
ID：清洗后，原始P1_轨迹的起始时间点（秒级别）  类型字符str  例子: 251273059_20250611_030130   24小时制  轨迹的起始时刻是凌晨3点01分钟30秒
PARTNO：日期，只精确到日，向前向后填充满就行
P1: 查询这轨迹的P1列，统计里面占比最高的字符串，填充整个P1列
GP：字符串显示，向前填充，向后填充，如果全null是nan，就保持都是null是nan。
H：高度，float，WGS84坐标系，单位米
JD：经度，float，WGS84坐标系
WD：纬度，float，WGS84坐标系
TASK：任务，字符串，查询这轨迹的TASK列，统计里面占比最高的字符串，填充整个TASK列，如果是null或者nan就保持nan
PLANETYPE：机型，字符串，会包含中文，查询这轨迹的PLANETYPE列，统计里面占比最高的字符串，填充整个PLANETYPE列，如果是null或者nan就保持nan
Time：20250619 09:17:00.000， 年月日 小时:分钟:秒.毫秒  取代原始数据DTRQ列




现在要实现一个功能，我们要把预测结果保存下来，方便可视化.
清洗好的轨迹数据有很多几万条，1700多万个采样点，采样间隔5s，大约3.5gb,每个轨迹有都自己的ID，还有上面描述的其他类型的数据。
现在有一个web前端，他需要历史数据（5分钟或者一定的时间）和预测的数据（对应预测未来1分钟、2分钟或者3分钟）（深度模型对历史轨迹数据滑窗读取（3分6分钟或9分钟），模型进行预测（对应预测未来1分钟2分钟3分钟），然后保存预测的滑窗数据成Parquet或者csv）。
现在，那就得到了两个文件，一个是没有滑窗的历史数据csv，一个是储存了一个滑窗的未来数据的csv，需要把历史数据和预测数据对应起来。
我计划通过p1也就是id来，加上时间戳对应。
历史数据是有时间列的，包含时间信息。
历史数据的3分钟窗口，的第一数据点的p1和秒级别时间，取出来，作为对应的标记，然后给预测窗口（1分）的p1列，重新组合:原始P1_历史窗口的末尾时间点（秒级别），也就是对应的预测窗口的p1列全部数据和历史窗口的p1列的第一个采样点相同。以此完成历史数据和预测滑窗的对应。


预测数据储存格式：
UTF-8编码
采样间隔1秒或者5秒

Pred_trajectory_id: STRING (与历史数据的ID一致, 例如 251273059_20250611_030130)
这是原始轨迹的唯一标识。
prediction_anchor_time: TIMESTAMP (或与TIME列格式一致的STRING)
这是输入模型的历史滑窗的最后一个数据点的时间戳。这个时间点是预测的“基准”或“锚点”。
例如，如果历史滑窗是 [03:00:00, 03:00:30, ..., 03:02:30]，那么 prediction_anchor_time 就是 03:02:30。
H_predicted: FLOAT
JD_predicted: FLOAT
WD_predicted: FLOAT
TASK: STRING (可从历史数据继承或关联查询得到)
PLANETYPE: STRING (可从历史数据继承或关联查询得到)
... (其他预测特征)




# 2.修改Data_loader，重新进行推理保存数据
在data_loader的时候读入推理数据集的ID H JD WD DTRQ等数据，进行模型推理的时候只使用H JD WD的数据，但是推理结束保存parquet格式就要带上ID等其余的信息，为了后续输入和输入预测端口合理对接  

你不应该修改原来的data_loader.py文件，你应该创建一个新的文件，比如叫data_loader_for_inference.py，然后在新的文件中实现你的修改。
如果推理用的主函数也有大量修改，那么也请创建一个新的文件，比如叫inference_for_web.py，然后在新的文件中实现你的修改。
我们希望训练和推理是分开的。现在训练已经正常运行了，详情可以参考/workspace/data/PatchTST/PatchTST_supervised/scripts/PatchTST/flight.sh




 

